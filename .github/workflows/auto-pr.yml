name: Auto Generate PR with Template

on:
  push:
    branches:
      - 'feat#*'
      - 'fix#*'
      - 'refactor#*'
    
jobs:
  create-pr:
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      issues: read

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get Commit Messages and PR Template
        id: get-content
        run: |
          COMMITS=$(git log origin/main..HEAD --pretty=format:"- %s")
          echo "commits<<EOF" >> $GITHUB_ENV
          echo "$COMMITS" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          TEMPLATE=$(cat .github/pull_request_template.md)
          echo "template<<EOF" >> $GITHUB_ENV
          echo "$TEMPLATE" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Get Issue Title
        id: get-issue-title
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BRANCH_NAME="${{ github.ref_name }}"
          # 'feat#123-description' 같은 브랜치 이름에서 숫자 '123'만 추출
          ISSUE_NUMBER=$(echo "$BRANCH_NAME" | grep -o -E '#[0-9]+' | sed 's/#//')
          
          if [ -z "$ISSUE_NUMBER" ]; then
            echo "브랜치 이름에서 이슈 번호를 찾을 수 없습니다."
            # 이슈 번호가 없으면, 브랜치 이름을 기반으로 제목 생성
            ISSUE_TITLE="${{ github.ref_name }}"
          else
            # GitHub CLI를 사용해서 이슈 제목을 가져와
            ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title -q ".title")
          fi
          
          echo "title=$ISSUE_TITLE" >> $GITHUB_OUTPUT

      - name: Generate PR Body with AI
        id: generate-body
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const commitMessages = process.env.commits;
            const prTemplate = process.env.template;
            const geminiApiKey = process.env.GEMINI_API_KEY;

            if (!geminiApiKey) {
              core.setFailed('GEMINI_API_KEY secret is not set.');
              return;
            }

            const prompt = `
              다음 Pull Request 템플릿의 각 항목을, 아래 제공된 커밋 메시지들을 바탕으로 채워줘.
              특히 '요약', '주요 변경 사항', '상세 구현 내용'을 중심으로 작성하고,
              '트러블 슈팅'이나 '알려진 이슈'는 커밋 내용에 근거가 없으면 비워둬도 좋아.
              최종 결과는 완성된 마크다운 텍스트만 반환해줘.

              --- PR 템플릿 ---
              ${prTemplate}

              --- 커밋 메시지 목록 ---
              ${commitMessages}
            `;

            // 무료 티어에서 확실히 사용 가능한 모델: Gemini 2.0 Flash
            // - RPM: 15, TPM: 1,000,000, RPD: 200 
            // - 안정적이고 빠름, 무료 할당량 보장
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${geminiApiKey}`;
            
            // 재시도 로직 구현
            const maxRetries = 3;
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
              try {
                console.log(`API 호출 시도 ${attempt}/${maxRetries}`);
                
                const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                      temperature: 0.7,
                      topK: 1,
                      topP: 1,
                      maxOutputTokens: 2048,
                    },
                    safetySettings: [
                      {
                        category: "HARM_CATEGORY_HARASSMENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_HATE_SPEECH",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      },
                      {
                        category: "HARM_CATEGORY_DANGEROUS_CONTENT",
                        threshold: "BLOCK_MEDIUM_AND_ABOVE"
                      }
                    ]
                  }),
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  const error = new Error(`API request failed: ${response.status} ${response.statusText}\nError: ${errorText}`);
                  
                  // 429 에러 (Rate Limit)인 경우 재시도 대기
                  if (response.status === 429 && attempt < maxRetries) {
                    const waitTime = Math.pow(2, attempt) * 1000; // 지수 백오프
                    console.log(`Rate limit 초과. ${waitTime}ms 후 재시도...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                    lastError = error;
                    continue;
                  }
                  
                  throw error;
                }

                const result = await response.json();
                
                // 전체 응답 로깅 (디버깅용)
                console.log('Full Gemini Response:', JSON.stringify(result, null, 2));

                // 안전한 속성 접근을 위한 검증
                if (!result) {
                  throw new Error('Gemini API returned null or undefined result');
                }

                // 에러 응답 처리
                if (result.error) {
                  throw new Error(`Gemini API returned error: ${JSON.stringify(result.error)}`);
                }

                // candidates 배열 검증
                if (!result.candidates || !Array.isArray(result.candidates) || result.candidates.length === 0) {
                  throw new Error(`Gemini API returned no candidates. This might be due to safety settings or content filtering.\nFull response: ${JSON.stringify(result)}`);
                }

                // 첫 번째 후보의 구조 검증
                const candidate = result.candidates[0];
                if (!candidate || !candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
                  throw new Error(`Invalid candidate structure in Gemini response.\nCandidate: ${JSON.stringify(candidate)}`);
                }

                // 안전하게 텍스트 추출
                let aiResponse = candidate.content.parts[0].text;
                if (!aiResponse || typeof aiResponse !== 'string') {
                  throw new Error(`Invalid or empty text response from Gemini.\nParts: ${JSON.stringify(candidate.content.parts)}`);
                }

                aiResponse = aiResponse.replace(/^```markdown\n/, '').replace(/\n```$/, '');
                console.log('Generated PR body:', aiResponse);
                core.setOutput('body', aiResponse);
                return; // 성공 시 함수 종료

              } catch (error) {
                lastError = error;
                console.log(`시도 ${attempt} 실패:`, error.message);
                
                if (attempt === maxRetries) {
                  break; // 마지막 시도면 루프 종료
                }
                
                // 마지막 시도가 아니면 잠시 대기
                const waitTime = 1000 * attempt;
                console.log(`${waitTime}ms 후 재시도...`);
                await new Promise(resolve => setTimeout(resolve, waitTime));
              }
            }
            
            // 모든 재시도 실패 시 에러 발생
            core.setFailed(`모든 API 호출 시도 실패: ${lastError?.message || '알 수 없는 오류'}`);
            return;
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}

      - name: Create Pull Request
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_BODY: ${{ steps.generate-body.outputs.body }}
        run: |
          gh pr create \
            --base main \
            --head ${{ github.ref_name }} \
            --title "feat: ${{ github.ref_name }}" \
            --body "$PR_BODY"